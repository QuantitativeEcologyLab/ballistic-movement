---
title: "Ballistic Motion Simulation Sensitivity"
author: "Lynndsay Terpsma"
date: \today
header-includes:
  - \usepackage{placeins}
output:
  pdf_document: 
    toc: true
    toc_depth: 3
    number_sections: false
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  root.dir = '~/hdrive/GitHub/ballistic-movement',
  echo = FALSE,
  cache = FALSE
)
#prevent figures from floating
knitr::knit_hooks$set(plot = function(x, options) {
  paste0(knitr::hook_plot_tex(x, options), "\n\\FloatBarrier\n")
})
source('~/hdrive/GitHub/ballistic-movement/scripts/functions.R') #custom functions for simulation model
library(dplyr) #  for data wrangling
library(ggplot2) # for plotting
library(minpack.lm) # for fitting nls model
library(mgcv) # for gam model
library(rcartocolor) # for color palettes
library(kableExtra)
# hex codes for color palette used
#carto_color_antique <- list("#855C75", "#D9AF6B", "#AF6458", "#736F4C", "#526A83", "#625377", "#68855C", "#9C9C5E", "#A06177", "#8C785D", "#467378", "#7C7C7C")
```

```{r xtr func, include = FALSE}
# custom function for drawing circles on raster figures to mark the home range area
circleFun <- function(center = c(0,0),diameter = 1, npoints = 100){
  r = diameter / 2
  tt <- seq(0,2*pi,length.out = npoints)
  xx <- center[1] + r * cos(tt)
  yy <- center[2] + r * sin(tt)
  return(data.frame(x = xx, y = yy))
}
```

## Introduction

This document will deal with the sensitivity of the scaling dependencies in the ballistic motion simulation setup, across the mass spectrum. 
The simulation is potentially sensitive to the parameters

  * patch width
  * sampling frequency 
  * calories per patch
  
To assess the variability across the mass spectrum, we looked at 3 masses: 100, 30000, and 5000000 grams. These values were chosen based on realistic terrestrial mammal sizes, spread across the mass spectrum. 30000 grams is a mass for which the model is consistently stable. 100 and 5000000 grams each represent the tails of the mass distribution, where the model has been unpredictable and unstable.  

For this analysis, we use the `ctmm` package (version 1.2.0, Fleming and Calabrese 2023) for movement modelling; the `terra` package (version 1.8-56, Hijmans 2025) to generate the raster of simulated resources; the `dplyr` package (version 1.1.4, Wickham et al. 2023) for data wrangling; the `minpack.lm` (version 1.2-4, Elzhor et al. 2023) and the `mgcv` (Wood, 2011) packages for fitting non-linear models to simulated data; the `ggplot2` package (version 3.5.2, Wickham 2016) for data visualization, and the `rcartocolor` package (version 1.0.0, Nowosad 2018) for color-blind safe colour palettes.  

## 30000 grams
### Patches per 95% HR area

For the first set of analyses, we chose to look at the 30000 gram individual, where the model has been consistently behaving.  

To start, we wanted to see have the number of patches visited changed with the number of patches available in the 95% home range area. To do this, we created a function, utilizing the `terra` package, which created a raster based on the size of 99.9% home range (HR) area. To determine the size of the patches, we chose how many patches were able to fit into the 95% HR area and scaled the width of each patch accordingly. Figure 1 shows a HR raster for a 30000 gram organism, with 5 patches in the 95% HR area. The number of patches in the 95% HR area will be henceforth referred to as $k$.  

```{r fig1_food_raster, fig.cap ="The raster that contains resources for simulated individuals. The blue circle marks the 95% home range area, while the green circle shows the 99.9% home range area, used for the extent of the raster. The white grid lines show the size of the patches, for this example, there are 5 patches ($k = 5$) in the 95% HR area."}
mass <- 30000
FOOD <- createFoodRaster(mass, k = 5, calories = 1)
df_raster <- as.data.frame(FOOD, xy = TRUE)
colnames(df_raster) <- c("x", "y", "calories")
xlines <- unique(df_raster$x)
ylines <- unique(df_raster$y)
HR <- round(sqrt((-2*log(0.05)*pi)*prey.SIG(mass)))
EXT <- round(sqrt((-2*log(0.0001)*pi)* prey.SIG(mass)))
HR_area <- circleFun(diameter = 2*HR)
EXT_area <- circleFun(diameter = 2*EXT)
ggplot() +
  geom_raster(data = df_raster, aes(x = x, y = y, fill = factor(calories))) +
  scale_fill_manual(values = c("grey70")) +
  geom_vline(xintercept = xlines, color = "white", alpha = 0.5) +
  geom_hline(yintercept = ylines, color = "white", alpha = 0.5) +
  geom_path(dat = HR_area, aes(x,y), color = "#467378") +
  geom_path(dat = EXT_area, aes(x,y), color = "#68855C") + 
  coord_equal() +
  theme.qel(legend = FALSE)
```

After confirmation that the new food raster function behaved as expected, we ran an analysis for $k$ values 1 to 1000001, jumping by 50. Each test generated a single, identical movement path, and counted the number of patches visited by the individual. The sampling interval for this test was equal to the velocity autocorrelation timescale ($\tau_v$). The results were then fitted to the logistic model using the `minpack.lm` package, as this package is more robust to incorrect starting parameters, making the fit easier. Upon receiving the first model fit, the values for a, b, and c from the model were then inputted back in the `nls.LM` function to return the final model. Figure 2 shows the results of this analysis, along with the model predictions.  

```{r fig2_30000g_patches, echo = TRUE, fig.cap = "The proportion of patches visited by the same track as a function of the number patches were available in the 95% home range area, for a mass of 30000 grams. The black line shows the predicted relationship from a logistic model using the \\texttt{nlsLM} package. The dashed line at $k = 236812$ is the value required to achieve 95% of the asymptote for patches visited. The solid line is the value 240000, the value for $k$ chosen for subsequent analyses."}
load("~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/30000g_vary_patches_details.Rda")
FIT <- nlsLM(patches ~ c * exp(a + b * log(k)) / (1 + exp(a + b * log(k))),
              start = list(a = - 5, b = 1e-5, c = 5100),
              data = patch_results_df)

a <- coef(FIT)["a"]
b <- coef(FIT)["b"]
c <- coef(FIT)["c"]
# 0.95 * c = (c * exp(a + b * log(k)) / (a + exp(a + b * log(k))))
k_95 <- exp((log(19) - a)/b)

patch_results_df %>% 
  mutate(model = predict(FIT)) %>% 
  ggplot() +
  geom_point(aes(x = k, y = patches), size = 1.2, alpha = 0.6, col = "#625377") +
  geom_line(aes(x = k, y = model), col = "#000", linewidth = 0.8, alpha = 0.7) +
  labs(y = "patches visited", x = 'patches in 95% HR') +
  geom_vline(xintercept = k_95, linetype = "dashed", col = "grey50") +
  geom_vline(xintercept = 240000, col = "grey50") +
  theme.qel()
```

### Effect of the sampling frequency

Next, we wanted to look at how the sampling frequency affects the number of patches visited. The sampling frequency was calculated as the the rounded velocity autocorrelation ($\tau_v$) divided by factor $x$. Values of $x$ from 0.5 to 500 were sampled in intervals of 0.5. We choose to test with $k = 240000$ (the $k$ necessary to reach 95% of maximum patch visits is 236811.12, which we rounded up to 240000, for a mass of 30000 grams). We then generated three movement paths (using seeds 1, 2, and 3), from the same movement model, to ensure consistency of the patch visits.  

To determine a reasonable sampling interval, we fit a Generalized Additive Model (GAM) to the data and calculated the $x$ necessary to reach 95% of the maximum patch visits recorded. The results of this analysis show that a sampling interval of approximately 3.5 seconds limits the amount of computational power needed, while retraining adequate patch visits for a 30000 gram individual. This corresponds with a $x$ value of 40.5, thus the sampling interval used for subsequent tests was determined to be $\frac{\tau_v}{40.5}$. The results of this GAM model were used to determine the sampling interval. Figure 3 shows the results of a GAM model created with the `geom_smooth()` function from the `ggplot2` package.

In addition, we have included the three movement tracks used to generate this data, overlaid on the full raster used, in figure 4. For brevity, we have only included the movement tracks for the 30000 gram individual.  

```{r 30000_x_95, echo = TRUE}
#fitting a GAM model to the sampling interval data
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/30000g_vary_interval_details.Rda')
gam_fit1 <- gam(patches ~ s(x), data = interval_res)

summary(gam_fit1)
```

```{r table1_30000_x}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/30000g_vary_interval_details.Rda')

#extract the value of x to reach 95% of the maximum patch visits
x_vals <- seq(500, 0.5, -0.5)
y_pred <- predict(gam_fit1, newdata = data.frame(x = x_vals))
y_target <- 0.95 * max(y_pred)
x_95 <- x_vals[which.min(abs(y_pred - y_target))]

t1 <- sampling(30000, x = x_95)
interval1 <- attr(t1, "interval")
max1 <- interval_res %>% 
  group_by(seed) %>% 
  summarise(max_patch = max(patches),
            tau_v = prey.tau_v(30000),
            interval_used = interval1,
            x_used = 40.5)

data.frame(max1) %>% 
  kable(caption = "Summary of the simulation results for testing the effect of the sampling interval on the number of patches visited on a 30000 gram organism. The table shows the estimate $x$ value ($x_{used}$) required to achieve a sampling interval ($s$) fine enough to detect 95% of maximum patch visits ($interval_{used}$). Also reported are the maximum number of patches visited and the velocity autocorrelation timescale ($tau_v$), grouped by seed.")
```


```{r fig3_30000gsampling, fig.cap = "The proportion of patch visits detected as a function of sampling interval chosen for a 30000 gram individual, grouped by their seed. The coloured lines show the estimated relationship based on a Generalized Additive Model fit using the \\texttt{geom\\_smooth()} function from the \\texttt{ggplot2} package. The black line shows sampling interval of 3.5 seconds, corresponding to $x$ equal to 40.5."}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/30000g_vary_interval_details.Rda')
interval_res <- interval_res %>% 
  group_by(seed) %>% 
  mutate(frac = patches / max(patches), #calculate the proportion of encounters with patches
         seed = as.factor(seed)) #convert seed to factor 

# interval <-
ggplot(interval_res, aes(x = log2(interval), y = frac)) + #log2 to show the effect of doubling the sampling interval
  geom_point(size = 1.5, alpha = 0.7) +
  scale_x_continuous(labels = function(x)2^x) +
  facet_grid(seed ~ .) +
  geom_smooth(aes(color = seed), method = 'gam', formula = y ~s(x)) +
  scale_color_carto_d(palette = "Antique") +
  labs(y = "patches visited", x = "sampling interval") +
  geom_vline(xintercept = log2(3.6)) +
  theme.qel() +
  theme(strip.text.y = element_blank()) #removes facet_grid labels
```


```{r fig4_30000ginterval_tracks, fig.cap = "Full movement tracks for each seed of the analysis, prior to being thinned, for a 30000 gram individuals, coloured by seed. The blue circle represents the 95% home range area, while the green circle represents the 99.9% home range area. Patches are indicated with white horizontal and vertical lines."}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/30000g_vary_interval_tracks.Rda')
mass_int <- 30000
food_int <- createFoodRaster(mass_int, k = 100000)
df_raster_int <- as.data.frame(food_int, xy = TRUE)
colnames(df_raster_int) <- c("x", "y", "calories")

#convert seed to factor
tracks_comb <- tracks_comb %>% 
  mutate(seed = as.factor(seed)) 
  
colnames(tracks_comb)[2:3] <- c("x", "y")

xlines <- unique(df_raster_int$x)
ylines <- unique(df_raster_int$y)

HR <- round(sqrt((-2*log(0.05)*pi)*prey.SIG(mass_int)))
EXT <- round(sqrt((-2*log(0.0001)*pi)* prey.SIG(mass_int)))
HR_area <- circleFun(diameter = 2*HR)
EXT_area <- circleFun(diameter = 2*EXT)

ggplot() +
  geom_raster(data = df_raster_int, aes(x = x, y = y, fill = factor(calories)), show.legend = FALSE) +
  scale_fill_manual(values = c("grey70")) +
  geom_vline(xintercept = xlines, color = "white", linewidth = 0.01, alpha = 0.5) +
  geom_hline(yintercept = ylines, color = "white", linewidth = 0.01, alpha = 0.5) +
  geom_path(dat = HR_area, aes(x,y), linewidth = 0.5, color = "#467378") +
  geom_path(dat = EXT_area, aes(x,y), linewidth = 0.5, color = "#68855C") +
  geom_path(data = tracks_comb, aes(x = x, y = y, group = seed, color = seed), linewidth = 0.3, alpha = 0.8) +
  scale_color_carto_d(palette = "Antique") +
  coord_equal() +
  theme.qel()
```

### Calories per patch

Finally, we needed to observe the sensitivity to calories per patch under the new simulation setup parameters. Thus, we conducted an analysis with the number of patches in the 95% HR area set to 240000 and the sampling interval set to approximately 3.5 seconds. We tested calorie per patch (kcal/patch) values from 0 to 10, by 0.5 kcal increments, as well as values 1.1, 1.2, 1.3, and 1.4. Based on these results, the lowest value of kcal/patch which produces viable offspring for this simulation setup is 1.1 kcal/patch. Figure 5 shows this relationship.  
The basal metabolic rate (BMR) of the organism was ignored for this analysis. Thus only the metabolic cost of speed was relevant for offspring production. We expect that the number bare minimum number of kcal/patch would increase when the BMR cost is added back into the simulation.

```{r fig5_30000g_offspring, fig.cap = "The number of offspring produced as a function of the number of kcalories available in each patch, for a 30000 gram individal. The kcalories per patch needed to achieve one offspring lies between 1 and 1.5."}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/30000g_vary_kcal_per_patch.Rda')
patch_results_df <- bind_rows(patch_results)

load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/30000g_vary_kcal_per_patch2.Rda')
patch_results_df2 <- bind_rows(patch_results)

results <- bind_rows(patch_results_df, patch_results_df2)

ggplot(results, aes(x = calories, y = offspring)) +
  geom_point(size = 1.5, alpha = 0.7) +
  labs(y = "offspring", x = 'kcal per patch') +
  theme.qel()
```

### Further investigation
In addition to the original test for the value of $k$ with a sampling interval equal to velocity autocorrelation, we conducted a final test with the new sampling interval of $\frac{\tau_v}{40.5}$. This analysis shows that with the new sampling interval, the value of $k$ needs to be increased to 26415225733 to be able for the 30000 gram individual to reach 95% of the maximum number of patch visits. The vertical line showing this value was removed from figure 6 for clarity. This presents a problem where adjusting the sampling interval will adjust the number of patches needed, which will affect the sampling interval needed, and the cycle repeats. Thus we chose to leave the values at 240,000 patches in the 95% HR area and the sampling interval at $\frac{1}{40.5}$ of $\tau_v$.

```{r fig6_30000g_patches_decreasedinterval, echo = TRUE, fig_cap = "The proportion of patches visited by the same track as a function of the number patches were available in the 95% home range area, for a mass of 30000 grams. The black line shows the predicted relationship from a logistic model using the \\texttt{nlsLM} package. The solid line shows $k = 240000$."}
load("~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/30000g_vary_k_new-interval.Rda")
patch_results_df <- do.call(rbind, patch_results)
FIT4 <- nlsLM(patches ~ c * exp(a + b * log(k)) / (1 + exp(a + b * log(k))),
              start = list(a = -7.98, b = 0.883, c = 5208),
              data = patch_results_df)

a <- coef(FIT4)["a"]
b <- coef(FIT4)["b"]
c <- coef(FIT4)["c"]
k_95 <- exp((log(19) - a)/b)

patch_results_df %>% 
  mutate(model = predict(FIT4)) %>%
  ggplot() +
  geom_point(aes(x = k, y = patches), size = 1.2, alpha = 0.6, col = "#625377") +
  geom_line(aes(x = k, y = model), col = "#000", linewidth = 0.8, alpha = 0.7) +
  labs(y = "patches visited", x = 'patches in 95% HR') +
  # geom_vline(xintercept = k_95, linetype = "dashed", col = "grey50") +
  geom_vline(xintercept = 240000, col = "grey50") +
  theme.qel()
```

## 100 grams
### Patches per 95% HR area

Next, to confirm that the results are consistent in the problematic areas, we looked at a 100 gram organism, following the same procedure. First we looked at the number of patches visited as a function of the number of patches in the 95% HR area ($k$). The analysis was conducted with a sampling interval equal to the $\tau_v$ value for the 100 gram individual.
Figure 7 shows the results of the test for a 100 gram individual. The number of patches required to be able to detect 95% of the patch encounters is 35726, which lies far below our chosen value of 240000, thus continuing to use the 240000 for $k$ should not lead to significant difference in the results.  

```{r fig7_100g_patches, echo = TRUE, fig.cap = "The proportion of patches visited by the same track,as a function of the number of patches were available in the 95% home range area, for a 100 gram individual. The black line shows the predicted relationship from a logistic model using the \\texttt{nlsLM} package. The dashed line shows the value of $k$ needed to reach 95% of the maximum patch enconuters, while the solid line shows the chosen value of $k$ (240000) for subsequent analyses."}
load("~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/100g_vary_k.Rda")
patch_results_df <- do.call(rbind, patch_results)

FIT2 <- nlsLM(patches ~ c * exp(a + b * log(k)) / (1 + exp(a + b * log(k))),
              start = list(a = 228, b = 3.48, c = 150805),
              data = patch_results_df)

a <- coef(FIT2)["a"]
b <- coef(FIT2)["b"]
c <- coef(FIT2)["c"]
k_95 <- exp((log(19) - a)/b)

patch_results_df %>% 
  mutate(model = predict(FIT2)) %>%
  ggplot() +
  geom_point(aes(x = k, y = patches), size = 1.2, alpha = 0.6, col = "#625377") +
  geom_line(aes(x = k, y = model), col = "#000", linewidth = 0.8, alpha = 0.7) +
  labs(y = "patches visited", x = 'patches in 95% HR') +
  geom_vline(xintercept = k_95, linetype = "dashed", col = "grey50") +
  geom_vline(xintercept = 240000, col = "grey50") +
  theme.qel()
```

### Effect of the sampling frequency

To investigate the effect of the sampling interval for smaller body sizes, we conducted the same procedure as for the 30000 gram individual, by creating a single track with a small sampling interval and then thinning to represent larger sampling intervals. The only difference in this test is that the smallest sampling interval was one-one hundredth of the velocity autocorrelation, compared to the one-five hundredth used for the 30000 gram and the 5000000 gram individuals. This change was made due to the mass dependency on $\tau_v$, such that small masses have small $\tau_v$ values, thus, without the change the analysis would require large amounts of computing power and time.  

To determine a reasonable sampling interval, we fit a GAM, with the same methods as for the 30000 gram individual. The results of this model showed that the value of $x$ needed to reach 95% of the maximum patch encounters would be 468, and thus the sampling interval would be $\frac{\tau_v}{468}$. However, this value would be incredibly unreasonable to use, as the sampling interval would be beyond fractions of a second and would take too long to run in a reasonable time frame. Thus, we continued with the value of 40.5 for $x$ for the following analyses, which is already a computationally heavy value for the sampling interval. Figure 8 shows these results.

```{r 100_x_95, echo = TRUE}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/100g_vary_interval_details.Rda')

#fitting a GAM model to the sampling interval data
gam_fit2 <- gam(patches ~ s(x), data = interval_res)

summary(gam_fit2)
```

```{r table2_100_x}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/100g_vary_interval_details.Rda')

#extract the value of x to reach 95% of the maximum patch visits
x_vals <- seq(500, 0.5, -0.5)
y_pred <- predict(gam_fit2, newdata = data.frame(x = x_vals))
y_target <- 0.95 * max(y_pred)
x_95_2 <- x_vals[which.min(abs(y_pred - y_target))]

t2 <- sampling(100, x = 40.5)
interval2 <- attr(t2, "interval")
t2_95 <- sampling(100, x = x_95_2)
interval2_95 <- attr(t2_95, "interval")
max2 <- interval_res %>% 
  group_by(seed) %>% 
  summarise(max_patch = max(patches),
            tau_v = prey.tau_v(100),
            interval_used = interval2,
            interval_95 = interval2_95,
            x_used = 40.5,
            x_95 = x_95_2
            )

data.frame(max2) %>% 
  kable(caption = "Summary of the simulation results for testing the effect of the sampling interval on the number of patches visited on a 100 gram organism. The table shows the estimate $x$ value ($x_{95}$) required to achieve a sampling interval ($s$) fine enough to detect 95% of maximum patch visits ($interval_{95}$). The table also compared this to the actual $x$ value used in subsequent simulations ($x_used$ and its corresponding sampling interval ($interval_{used}$). Also reported are the maximum number of patches visited and the velocity autocorrelation timescale ($tau_v$), grouped by seed.")
```


```{r fig8_100gsampling, fig.cap = "The proportion of patch visits detected as a function of sampling interval chosen for a 100 gram individual, grouped by their seed. The coloured lines show the estimated relationship based on a Generalized Additive Model fit using the \\texttt{geom\\_smooth()} function from the \\texttt{ggplot2} package. The black line shows sampling interval of 0.05 seconds, corresponding to $x$ equal to 40.5."}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/100g_vary_interval_details.Rda')
interval_res <- interval_res %>% 
  group_by(seed) %>% 
  mutate(frac = patches / max(patches), #calculate the proportion of encounters with patches
         seed = as.factor(seed)) #convert seed to factor 

# interval <-
ggplot(interval_res, aes(x = log2(interval), y = frac)) + #log2 to show the effect of doubling the sampling interval
  geom_point(size = 1.5, alpha = 0.7) +
  scale_x_continuous(labels = function(x)2^x) +
  facet_grid(seed ~ .) +
  geom_smooth(aes(color = seed), method = 'gam', formula = y ~s(x)) +
  scale_color_carto_d(palette = "Antique") +
  labs(y = "patches visited", x = "sampling interval") +
  geom_vline(xintercept = log2(0.05)) +
  theme.qel() +
  theme(strip.text.y = element_blank()) #removes facet_grid labels
```

### Calories per patch

For the 100 gram individual, we tested calorie per patch (kcal/patch) values of 0.00010, 0.00015, 0.00020, 0.00025, 0.00030, 0.00035, 0.00040, 0.00045, 0.00050, 0.00070, 0.00090, 0.00110, 0.00130, 0.00150, and 0.00170. Similarly to the 30000 gram individual test, this analysis was conducted with 240000 patches in the 95% HR area, with a sampling interval of $\frac{1}{40.5} * \tau_v$. Based on these results, the lowest value of kcal/patch which produces viable offspring for this simulation setup is between 0.00025 (zero offspring) and 0.00030 (four offspring) kcal/patch. Figure 9 shows the relationship between the kcal/patch value and the number of offspring produced. 

```{r fig9_100g_offspring, fig.cap = "The number of offspring produced as a function of the number of kcalories available in each patch, for a 100 gram individal. The kcalories per patch needed to achieve one offspring lies between 0.00025 and 0.0003."}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/100g_vary_kcal_per_patch2.Rda')
patch_results_df <- bind_rows(patch_results)

load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/100g_vary_kcal_per_patch3.Rda')
patch_results_df2 <- bind_rows(patch_results)

results <- bind_rows(patch_results_df, patch_results_df2)

ggplot(results, aes(x = calories, y = offspring)) +
  geom_point(size = 1.5, alpha = 0.7) +
  labs(y = "offspring", x = 'kcal per patch') +
  theme.qel()
```


## 5000000 grams
### Patches per 95% HR area
Finally, we prepared the same analysis for a mass of 5000000 grams. As before, we fit a logistic model to the data and extracted the value of $k$ needed to detect 95% of the maximum patch visits. For the 5000000 gram individual, this value is 179511. Figure 10 shows the result of this test and confirms that the chosen value of 240000 for $k$ should be appropriate across the mass spectrum without yielding significantly different results.    

```{r fig10_5000000g_patches, echo = TRUE, fig.cap = "The number of patches visited within the same movement track as a function of how many patches were available in the 95% home range area, for a 5000000 gram individual. The dashed line shows the value of $k$ needed to reach 95% of the maximum patch visits, while the solid line shows $k = 24000$, the value chosen for additional analyses."}
load("~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/5000000g_vary_k.Rda")
patch_results_df <- do.call(rbind, patch_results)

FIT3 <- nlsLM(patches ~ c * exp(a + b * log(k)) / (1 + exp(a + b * log(k))),
              start = list(a = -2.05, b = 0.0939, c = 2766),
              data = patch_results_df)

a <- coef(FIT3)["a"]
b <- coef(FIT3)["b"]
c <- coef(FIT3)["c"]
k_95 <- exp((log(19) - a)/b)

patch_results_df %>% 
  mutate(model = predict(FIT3)) %>% 
  ggplot() +
  geom_point(aes(x = k, y = patches), size = 1.2, alpha = 0.6, col = "#625377") +
  geom_line(aes(x = k, y = model), col = "#000", linewidth = 0.8, alpha = 0.7) +
  labs(y = "patches visited", x = 'patches in 95% HR') +
  geom_vline(xintercept = k_95, linetype = "dashed", col = "grey50") +
  geom_vline(xintercept = 240000, col = "grey50") +
  theme.qel()
```

### Effect of the sampling frequency

We then conducted the same analysis on the sampling frequency, for the 5000000 gram body size, setting 240000 patches in the 95% HR area. As before, we fit a GAM model to the data and extracted the value for $x$ that was needed to detect 95% of the maximum patch visits. This value matched identically to the 30000 gram body size, thus a value of $\frac{\tau_v}{40.5}$ should be appropriate to use as the sampling interval across the mass spectrum. Figure 11 shows the predicted relationship between the sampling interval and the proportion of patches visits detected, coloured by seed.  

```{r 5000000_x_95, echo = TRUE}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/5000000g_vary_interval_details.Rda')
#fit the GAM model to the data
gam_fit3 <- gam(patches ~ s(x), data = interval_res)

summary(gam_fit3)
```

```{r table3_5000000_x}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/5000000g_vary_interval_details.Rda')

#extract the value needed to 95% of the maximum patch visits
x_vals3 <- seq(500, 0.5, -0.5)
y_pred3 <- predict(gam_fit3, newdata = data.frame(x = x_vals3))
y_target3 <- 0.95 * max(y_pred3)
x_95_3 <- x_vals3[which.min(abs(y_pred3 - y_target3))]

t3 <- sampling(5000000, x = x_95_3)
interval3 <- attr(t, "interval")
max3 <- interval_res %>% 
  group_by(seed) %>% 
  summarise(max_patch = max(patches),
            tau_v = prey.tau_v(5000000),
            interval_used = interval3,
            x_used = 40.5
            )

data.frame(max3) %>% 
  kable(caption = "Summary of the simulation results for testing the effect of the sampling interval on the number of patches visited on a 5000000 gram organism. The table shows the estimate $x$ value ($x_{used}$) required to achieve a sampling interval ($s$) fine enough to detect 95% of maximum patch visits ($interval_{used}$). Also reported are the maximum number of patches visited and the velocity autocorrelation timescale ($tau_v$), grouped by seed.")
```


```{r fig11_5000000g_sampling, fig.cap = "The proportion of patch visits detected as a function of sampling interval chosen for a 5000000 gram individual, grouped by their seed. The coloured lines show the estimated relationship based on a Generalized Additive Model fit using the \\texttt{geom\\_smooth()} function from the \\texttt{ggplot2} package. The black line shows sampling interval of 200 seconds, corresponding to $x$ equal to 40.5."}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/5000000g_vary_interval_details.Rda')

interval_res <- interval_res %>% 
  group_by(seed) %>% 
  mutate(frac = patches / max(patches), #calculate the proportion of encounters with patches
         seed = as.factor(seed)) #convert seed to factor 

ggplot(interval_res, aes(x = log2(interval), y = frac)) + #log2 to show the effect of doubling the sampling interval
  geom_point(size = 1.5, alpha = 0.7) +
  scale_x_continuous(labels = function(x)2^x) +
  facet_grid(seed ~ .) +
  geom_smooth(aes(color = seed), method = 'gam', formula = y ~s(x)) +
  # scale_color_brewer(palette = "Dark2") +
  scale_color_carto_d(palette = "Antique") +
  labs(y = "patches visited", x = "sampling interval") +
  geom_vline(xintercept = log2(199.8)) +
  theme.qel() +
  theme(strip.text.y = element_blank()) #removes facet_grid labels
```

### Calories per patch

For the 5000000 gram individual, we used the same methods as previous analyses, with 240000 patches in the 95% HR area, with a sampling interval of $\frac{1}{40.5} * \tau_v$. We tested calorie per patch (kcal/patch) values from 0 to 6000, by 100 kcal increments. Based on these results, the lowest value of kcal/patch which produces viable offspring for this simulation setup is 2500 kcal/patch. The inconsistent results reveal that the value of kcal/patch will need to be scaled to the body mass.

```{r fig12_5000000g_offspring, fig.cap = "The number of offspring produced as a function of the number of kcalories available in each patch, for a 5000000 gram individal. The kcalories per patch needed to achieve one offspring is 2500."}
load('~/hdrive/GitHub/ballistic-movement/simulations/sensitivity/data/5000000g_vary_kcal_per_patch.Rda')
patch_results_df <- bind_rows(patch_results)

ggplot(patch_results_df, aes(x = calories, y = offspring)) +
  geom_point(size = 1.5, alpha = 0.7) +
  labs(y = "offspring", x = 'kcal per patch') +
  theme.qel()
```




