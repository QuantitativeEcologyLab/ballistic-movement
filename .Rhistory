break
}
#progress report
print(G)
}
return(prey_details)
}
#number of individuals in arena
n_prey <- 10
#number of arenas
REPS <- 5
#number of generations
GENS <- 5
masses <- seq(1000, 100000, 1000)
calories <- seq(3, 99, 3)
# Define your parameter combinations here
param_grid <- expand.grid(
mass = masses,
calories = calories
)
# Prepare a list to store all results
all_results <- list()
all_results <- parallel::mclapply(
1:nrow(param_grid),
mc.cores = 5,
FUN = function(i){
params <- param_grid[i,]
width <- round(sqrt(prey.SIG(params$mass))/15)
# Run the simulation with your exact code inside
res <- tryCatch({
run_sens(
mass_prey = params$mass,
calories = params$calories,
GENS = GENS,
REPS = REPS,
n_prey = n_prey,
width = width
)
}, error = function(e) {
warning(sprintf("Scenario %d failed: %s", i, e$message))
NULL  # store NULL so indexing is preserved
})
all_results[[i]] <- res
})
#number of individuals in arena
n_prey <- 10
#number of arenas
REPS <- 5
#number of generations
GENS <- 5
masses <- seq(1000, 100000, 1000)
calories <- seq(3, 99, 3)
# Define your parameter combinations here
param_grid <- expand.grid(
mass = masses,
calories = calories
)
all_results <- parallel::mclapply(
1:nrow(param_grid),
mc.cores = 5,
FUN = function(i){
params <- param_grid[i,]
width <- round(sqrt(prey.SIG(params$mass))/15)
message(sprintf("Starting scenario %d: Mass = %d, cal %d", i, params$mass, params$calories))
# Run the simulation with your exact code inside
res <- tryCatch({
run_sens(
mass_prey = params$mass,
calories = params$calories,
GENS = GENS,
REPS = REPS,
n_prey = n_prey,
width = width
)
}, error = function(e) {
warning(sprintf("Scenario %d failed: %s", i, e$message))
NULL  # store NULL so indexing is preserved
})
message(sprintf("Finished scenario %d", i))
return(res)
})
View(param_grid)
# Define your parameter combinations here
param_grid <- expand.grid(
mass = masses,
calories = calories
)
all_results <- parallel::mclapply(
1:nrow(param_grid),
mc.cores = 5,
FUN = function(i){
params <- param_grid[i,]
width <- round(sqrt(prey.SIG(params$mass))/15)
message(sprintf("Starting scenario %d: Mass = %d, cal %d", i, params$mass, params$calories))
# Run the simulation with your exact code inside
res <- tryCatch({
run_sens(
mass_prey = params$mass,
calories = params$calories,
GENS = GENS,
REPS = REPS,
n_prey = n_prey,
width = width
)
}, error = function(e) {
warning(sprintf("Scenario %d failed: %s", i, e$message))
NULL  # store NULL so indexing is preserved
})
message(sprintf("Finished scenario %d", i))
return(res)
})
#number of individuals in arena
n_prey <- 5
#number of arenas
REPS <- 5
#number of generations
GENS <- 5
masses <- seq(1000, 100000, 1000)
calories <- seq(3, 99, 3)
# Define your parameter combinations here
param_grid <- expand.grid(
mass = masses,
calories = calories
)
all_results <- parallel::mclapply(
1:nrow(param_grid),
mc.cores = 5,
FUN = function(i){
params <- param_grid[i,]
width <- round(sqrt(prey.SIG(params$mass))/15)
message(sprintf("Starting scenario %d: Mass = %d, cal %d", i, params$mass, params$calories))
# Run the simulation with your exact code inside
res <- tryCatch({
run_sens(
mass_prey = params$mass,
calories = params$calories,
GENS = GENS,
REPS = REPS,
n_prey = n_prey,
width = width
)
}, error = function(e) {
warning(sprintf("Scenario %d failed: %s", i, e$message))
NULL  # store NULL so indexing is preserved
})
message(sprintf("Finished scenario %d", i))
return(res)
})
source("~/H/GitHub/ballistic-movement/scripts/functions.R", echo = TRUE)
# Prey mass (g)
mass_prey <- 30000
#set sampling interval and lifespan
t <- sampling(mass_prey)
#number of individuals in arena
n_prey <- 30
#number of arenas
REPS <- 5
#number of generations
GENS <- 200
#build food raster
FOOD <- createFoodRaster(mass_prey, calories = 15, width = round(sqrt(prey.SIG(mass_prey)))/10)
#lists for storing results
prey_res <- list()
prey_details <- list()
for(G in 1:GENS) {
tic(paste("Generation", G))
prey <- list()
for(R in 1:REPS){
if (G == 1) {
CENTRES <- rbvpois(n = n_prey,
a = prey.SIG(mass_prey)*0.75,
b = prey.SIG(mass_prey)*0.75,
c = 0)
CENTRES <- scale(CENTRES, scale = FALSE)
PREY_mods <- list()
for(i in 1:n_prey){
prey_tau_p <- prey.tau_p(mass_prey, variance = TRUE)
prey_tau_v <- prey.tau_v(mass_prey, variance = TRUE)
prey_sig <- prey.SIG(mass_prey)
prey_lv <- sqrt((prey_tau_v/prey_tau_p) * prey_sig)
PREY_mods[[i]] <- ctmm(tau = c(prey_tau_p, prey_tau_v),
mu = c(CENTRES[i,1], CENTRES[i,2]),
sigma = prey_sig)
}
}
if (G!=1){
CENTRES <- rbvpois(n = n_prey,
a = prey.SIG(mass_prey)*0.75,
b = prey.SIG(mass_prey)*0.75,
c = 0)
CENTRES <- scale(CENTRES, scale = FALSE)
PREY_mods <- list()
for(i in 1:n_prey){
prey_tau_p <- sample(PREY_tau_p,1) + rnorm(1, 0, 10)
prey_tau_p <- ctmm:::clamp(prey_tau_p, min = 0.1, max = Inf)
prey_tau_v <- sample(PREY_tau_v,1) + rnorm(1, 0, 2)
prey_tau_v <- ctmm:::clamp(prey_tau_v, min = 0.1, max = Inf)
prey_sig <- sample(PREY_sig,1)
prey_lv <- sqrt((prey_tau_v/prey_tau_p)*prey_sig)
PREY_mods[[i]] <- ctmm(tau = c(prey_tau_p, prey_tau_v),
mu = c(CENTRES[i,1], CENTRES[i,2]),
sigma = prey_sig)
}
}
#simulate prey movement
PREY_tracks <- list()
for(i in 1:n_prey){
PREY_tracks[[i]] <- simulate(PREY_mods[[i]], t = t)
}
#extract ids of patches entered
benefits_prey <- vector("list", n_prey)
for(i in 1:n_prey){
benefits_prey[[i]] <- grazing(PREY_tracks[[i]], FOOD)
}
#extract number of changes between patches
patches <- vector("list", n_prey)
for(i in 1:n_prey){
patches[[i]] <- attr(benefits_prey[[i]], "patches")
}
#extract speed from model
speed <- numeric(n_prey)
for(i in 1:n_prey){
speed[[i]] <- speed_val(models = PREY_mods[[i]])
}
#assign net calories to each individual
cal_list <- vector("list", n_prey)
cal_net <- numeric(n_prey)
costs <- numeric(n_prey)
BMR <- numeric(n_prey)
Move <- numeric(n_prey)
for(i in 1:n_prey){
mass <- if(length(mass_prey) == 1) mass_prey else mass_prey[i]
cal_list[[i]] <- cals_net(IDs = benefits_prey[[i]],
habitat = FOOD,
mass = mass,
models = PREY_mods[[i]],
speed = speed[[i]],
t = t)
# Defensive: check result is valid
if (is.list(cal_list[[i]]) &&
all(c("cal_net") %in% names(cal_list[[i]]))) {
cal_net[i] <- cal_list[[i]]$cal_net
costs[i] <- cal_list[[i]]$costs
BMR[i] <- cal_list[[i]]$BMR
Move[i] <- cal_list[[i]]$Move
} else {
cal_net[i] <- NA
warning(sprintf("Invalid result from cals_net for individual %d", i))
}
}
#compute prey offspring
results <- prey.fitness(mass = mass_prey,
cal_net = cal_net)
offspring_prey <- results$offspring
mass_update_prey <- results$mass_update
#get values
prey_lvs <- vector()
prey_TAU_V <- vector()
prey_TAU_P <- vector()
prey_SIGMA <- vector()
for(i in 1:n_prey){
prey_TAU_V[i] <- PREY_mods[[i]]$tau["velocity"]
prey_TAU_P[i] <- PREY_mods[[i]]$tau["position"]
prey_SIGMA[i] <- ctmm:::area.covm(PREY_mods[[i]]$sigma)
prey_lvs[i] <- sqrt((prey_TAU_V[i]/prey_TAU_P[i])*prey_SIGMA[i])
}
#summarise
prey[[R]] <- data.frame(generation = G,
tau_p = prey_TAU_P,
tau_v = prey_TAU_V,
sig = prey_SIGMA,
lv = prey_lvs,
patches = unlist(patches),
cal_net = cal_net,
costs = costs,
speed = unlist(speed),
offspring = unlist(offspring_prey),
mass = mass_prey,
mass_update = unlist(mass_update_prey),
BMR = BMR,
Move = Move)
}
prey <- do.call(rbind, prey)
prey_res[[G]] <- data.frame(generation = G,
lv = mean(prey$lv),
var = var(prey$lv))
prey_details[[G]] <- prey
#Set up the parameters for the next generation based on
#Fitness of current generation
PREY_tau_p <- vector()
PREY_tau_v <- vector()
PREY_sig <- vector()
for(i in 1:nrow(prey)){
if(prey[i,"offspring"] >0){
PREY_tau_p <- c(PREY_tau_p,
rep(prey[i,"tau_p"], prey[i,"offspring"]))
PREY_tau_v <- c(PREY_tau_v,
rep(prey[i,"tau_v"], prey[i,"offspring"]))
PREY_sig <- c(PREY_sig,
rep(prey[i,"sig"], prey[i,"offspring"]))
} #Closes the if statement
} #closes loop over the number of prey
# If no offspring, save results and stop simulation
if(length(PREY_tau_p) == 0 || length(PREY_tau_v) == 0 || length(PREY_sig) == 0){
warning(sprintf("Simulation stopped early at generation %d due to extinction (no offspring)", G))
break
}
#progress report
print(G)
toc(log = TRUE)
}
# speed ~ tau_p
taup.speed <- ggplot(prey_details_df, aes(y = speed, x = tau_p)) +
stat_summary(fun = mean, geom = "line", col = "deeppink4", linewidth = 1) +
labs(y = "speed (m/s)", x = "tau_p (s)") +
theme_minimal()
prey_details_df <- do.call(rbind, prey_details)
# speed ~ tau_p
taup.speed <- ggplot(prey_details_df, aes(y = speed, x = tau_p)) +
stat_summary(fun = mean, geom = "line", col = "deeppink4", linewidth = 1) +
labs(y = "speed (m/s)", x = "tau_p (s)") +
theme_minimal()
print(taup.speed)
library(parallel)
# Set the working directory
setwd("~/H/GitHub/ballistic-movement")
# Set the random seed
set.seed(123)
# Import necessary packages
library(extraDistr)
library(parallel)
library(ctmm)
library(terra)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(patchwork)
library(tictoc)
# Source the functions (ensure 'functions.R' is available in the working directory)
source("scripts/functions.R")
Ncores <- 5
# Prey mass (g)
mass_prey <- 30000
#set sampling interval and lifespan
t <- sampling(mass_prey)
#number of individuals in arena
n_prey <- 30
#number of arenas
REPS <- 5
#number of generations
GENS <- 200
#number of generations
GENS <- 1000
#build food raster
FOOD <- createFoodRaster(mass_prey, calories = 15, width = round(sqrt(prey.SIG(mass_prey)))/10)
#lists for storing results
prey_res <- list()
prey_details <- list()
for(G in 1:GENS) {
prey <- list()
for(R in 1:REPS){
if (G == 1) {
CENTRES <- rbvpois(n = n_prey,
a = prey.SIG(mass_prey)*0.75,
b = prey.SIG(mass_prey)*0.75,
c = 0)
CENTRES <- scale(CENTRES, scale = FALSE)
PREY_mods <- list()
for(i in 1:n_prey){
prey_tau_p <- prey.tau_p(mass_prey, variance = TRUE)
prey_tau_v <- prey.tau_v(mass_prey, variance = TRUE)
prey_sig <- prey.SIG(mass_prey)
prey_lv <- sqrt((prey_tau_v/prey_tau_p) * prey_sig)
PREY_mods[[i]] <- ctmm(tau = c(prey_tau_p, prey_tau_v),
mu = c(CENTRES[i,1], CENTRES[i,2]),
sigma = prey_sig)
}
}
if (G!=1){
CENTRES <- rbvpois(n = n_prey,
a = prey.SIG(mass_prey)*0.75,
b = prey.SIG(mass_prey)*0.75,
c = 0)
CENTRES <- scale(CENTRES, scale = FALSE)
PREY_mods <- list()
for(i in 1:n_prey){
prey_tau_p <- sample(PREY_tau_p,1) + rnorm(1, 0, 10)
prey_tau_p <- ctmm:::clamp(prey_tau_p, min = 0.1, max = Inf)
prey_tau_v <- sample(PREY_tau_v,1) + rnorm(1, 0, 2)
prey_tau_v <- ctmm:::clamp(prey_tau_v, min = 0.1, max = Inf)
prey_sig <- sample(PREY_sig,1)
prey_lv <- sqrt((prey_tau_v/prey_tau_p)*prey_sig)
PREY_mods[[i]] <- ctmm(tau = c(prey_tau_p, prey_tau_v),
mu = c(CENTRES[i,1], CENTRES[i,2]),
sigma = prey_sig)
}
}
#simulate prey movement
# PREY_tracks <- list()
# for(i in 1:n_prey){
#   PREY_tracks[[i]] <- simulate(PREY_mods[[i]], t = t)
# }
PREY_tracks <- mclapply(PREY_mods,
FUN = simulate,
t = t,
mc.cores = Ncores)
#extract ids of patches entered
benefits_prey <- vector("list", n_prey)
for(i in 1:n_prey){
benefits_prey[[i]] <- grazing(PREY_tracks[[i]], FOOD)
}
#extract number of changes between patches
patches <- vector("list", n_prey)
for(i in 1:n_prey){
patches[[i]] <- attr(benefits_prey[[i]], "patches")
}
#extract speed from model
speed <- numeric(n_prey)
for(i in 1:n_prey){
speed[[i]] <- speed_val(models = PREY_mods[[i]])
}
#assign net calories to each individual
cal_list <- vector("list", n_prey)
cal_net <- numeric(n_prey)
costs <- numeric(n_prey)
BMR <- numeric(n_prey)
Move <- numeric(n_prey)
for(i in 1:n_prey){
mass <- if(length(mass_prey) == 1) mass_prey else mass_prey[i]
cal_list[[i]] <- cals_net(IDs = benefits_prey[[i]],
habitat = FOOD,
mass = mass,
models = PREY_mods[[i]],
speed = speed[[i]],
t = t)
# Defensive: check result is valid
if (is.list(cal_list[[i]]) &&
all(c("cal_net") %in% names(cal_list[[i]]))) {
cal_net[i] <- cal_list[[i]]$cal_net
costs[i] <- cal_list[[i]]$costs
BMR[i] <- cal_list[[i]]$BMR
Move[i] <- cal_list[[i]]$Move
} else {
cal_net[i] <- NA
warning(sprintf("Invalid result from cals_net for individual %d", i))
}
}
#compute prey offspring
results <- prey.fitness(mass = mass_prey,
cal_net = cal_net)
offspring_prey <- results$offspring
mass_update_prey <- results$mass_update
#get values
prey_lvs <- vector()
prey_TAU_V <- vector()
prey_TAU_P <- vector()
prey_SIGMA <- vector()
for(i in 1:n_prey){
prey_TAU_V[i] <- PREY_mods[[i]]$tau["velocity"]
prey_TAU_P[i] <- PREY_mods[[i]]$tau["position"]
prey_SIGMA[i] <- ctmm:::area.covm(PREY_mods[[i]]$sigma)
prey_lvs[i] <- sqrt((prey_TAU_V[i]/prey_TAU_P[i])*prey_SIGMA[i])
}
#summarise
prey[[R]] <- data.frame(generation = G,
tau_p = prey_TAU_P,
tau_v = prey_TAU_V,
sig = prey_SIGMA,
lv = prey_lvs,
patches = unlist(patches),
cal_net = cal_net,
costs = costs,
speed = unlist(speed),
offspring = unlist(offspring_prey),
mass = mass_prey,
mass_update = unlist(mass_update_prey),
BMR = BMR,
Move = Move)
}
prey <- do.call(rbind, prey)
prey_res[[G]] <- data.frame(generation = G,
lv = mean(prey$lv),
var = var(prey$lv))
prey_details[[G]] <- prey
#Set up the parameters for the next generation based on
#Fitness of current generation
PREY_tau_p <- vector()
PREY_tau_v <- vector()
PREY_sig <- vector()
for(i in 1:nrow(prey)){
if(prey[i,"offspring"] >0){
PREY_tau_p <- c(PREY_tau_p,
rep(prey[i,"tau_p"], prey[i,"offspring"]))
PREY_tau_v <- c(PREY_tau_v,
rep(prey[i,"tau_v"], prey[i,"offspring"]))
PREY_sig <- c(PREY_sig,
rep(prey[i,"sig"], prey[i,"offspring"]))
} #Closes the if statement
} #closes loop over the number of prey
# If no offspring, save results and stop simulation
if(length(PREY_tau_p) == 0 || length(PREY_tau_v) == 0 || length(PREY_sig) == 0){
warning(sprintf("Simulation stopped early at generation %d due to extinction (no offspring)", G))
save(prey_res, file = '~/H/GitHub/ballistic-movement/sim_results/constant_resources_nopred_varycalories/June9_30000g_15cal_1000gen_prey_res.Rda')
save(prey_details, file = '~/H/GitHub/ballistic-movement/sim_results/constant_resources_nopred_varycalories/June9_30000g_15cal_1000gen_prey_details.Rda')
break
}
#save results
save(prey_res, file = '~/H/GitHub/ballistic-movement/sim_results/constant_resources_nopred_varycalories/June9_30000g_15cal_1000gen_prey_res.Rda')
save(prey_details, file = '~/H/GitHub/ballistic-movement/sim_results/constant_resources_nopred_varycalories/June9_30000g_15cal_1000gen_prey_details.Rda')
#progress report
print(G)
}
